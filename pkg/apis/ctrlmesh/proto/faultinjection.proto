syntax = "proto3";
option go_package = "github.com/KusionStack/controller-mesh/pkg/apis/ctrlmesh/proto";
package proto;

import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";

service FaultInject {
  rpc SendConfig(FaultInjection) returns (InjectResp);
}

message InjectResp {
  bool success = 1;
  string message = 2;
}

message FaultInjection {
  repeated HTTPFaultInjection httpFaults = 1;

  Option option = 2;
  enum Option {
    UPDATE = 0;
    DELETE = 1;
  }
  string configHash = 3;
  string name = 4;
}

message HTTPFaultInjection {
  // Delay requests before forwarding, emulating various failures such as
  // network issues, overloaded upstream service, etc.
  Delay delay = 1;

  // Abort Http request attempts and return error codes back to downstream
  // service, giving the impression that the upstream service is faulty.
  Abort abort = 2;

  repeated HTTPMatchRequest match = 3;

  message Delay {
    // Percentage of requests on which the delay will be injected (0-100).
    // Use of integer `percent` value is deprecated. Use the double `percentage`
    // field instead.
    double percent = 1;

    oneof http_delay_type {
      // Add a fixed delay before forwarding the request. Format:
      // 1h/1m/1s/1ms. MUST be >=1ms.
      google.protobuf.Duration fixed_delay = 2 [(google.api.field_behavior) = REQUIRED];

      //google.protobuf.Duration exponential_delay = 3 ;
    }
  }

  message Abort {

    double percent = 1;

    oneof error_type {
      // HTTP status code to use to abort the Http request.
      int32 http_status = 2 [(google.api.field_behavior) = REQUIRED];

      // GRPC status code to use to abort the request. The supported
      // codes are documented in https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
      // Note: If you want to return the status "Unavailable", then you should
      // specify the code as `UNAVAILABLE`(all caps), but not `14`.
      string grpc_status = 3;

      // $hide_from_docs
      string http2_error = 4;
    }
  }
}

// HttpMatchRequest specifies a set of criterion to be met in order for the
// rule to be applied to the HTTP request. For example, the following
// restricts the rule to match only requests where the URL path
// starts with /ratings/v2/ and the request contains a custom `end-user` header
// with value `jason`.
//
// ```yaml
// spec:
//   httpFaults:
//   - match:
//     - headers:
//         end-user:
//           exact: jason
//       uri:
//         prefix: "/ratings/v2/"
//       ignoreUriCase: true
//     route:
//     - destination:
//         host: ratings.prod.svc.cluster.local
// ```
message HTTPMatchRequest {
  // The name assigned to a match. The match's name will be
  // concatenated with the parent route's name and will be logged in
  // the access logs for requests matching this route.
  string name = 1;

  //
  repeated ResourceMatch relatedResources = 2;
  // URI to match
  // values are case-sensitive and formatted as follows:
  //
  // - `exact: "value"` for exact string match
  //
  // - `prefix: "value"` for prefix-based match
  //
  // - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
  //
  // **Note:** Case-insensitive matching could be enabled via the
  // `ignore_uri_case` flag.
  StringMatch uri = 3;

  // URI Scheme
  // values are case-sensitive and formatted as follows:
  //
  // - `exact: "value"` for exact string match
  //
  // - `prefix: "value"` for prefix-based match
  //
  // - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
  //
  StringMatch scheme = 4;

  // HTTP Method
  // values are case-sensitive and formatted as follows:
  //
  // - `exact: "value"` for exact string match
  //
  // - `prefix: "value"` for prefix-based match
  //
  // - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
  //
  StringMatch method = 5;

  // HTTP Authority
  // values are case-sensitive and formatted as follows:
  //
  // - `exact: "value"` for exact string match
  //
  // - `prefix: "value"` for prefix-based match
  //
  // - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
  //
  StringMatch authority = 6;

  // The header keys must be lowercase and use hyphen as the separator,
  // e.g. _x-request-id_.
  //
  // Header values are case-sensitive and formatted as follows:
  //
  // - `exact: "value"` for exact string match
  //
  // - `prefix: "value"` for prefix-based match
  //
  // - `regex: "value"` for RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
  //
  // If the value is empty and only the name of header is specified, presence of the header is checked.
  // To provide an empty value, use `{}`, for example:
  //
  // ```
  //  - match:
  //    - headers:
  //        myheader: {}
  // ```
  // **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
  map<string, StringMatch> headers = 7;

  // Specifies the ports on the host that is being addressed. Many services
  // only expose a single port or label ports with the protocols they support,
  // in these cases it is not required to explicitly select the port.
  uint32 port = 8;

  // One or more labels that constrain the applicability of a rule to source (client) workloads
  // with the given labels. If the VirtualService has a list of gateways specified
  // in the top-level `gateways` field, it must include the reserved gateway
  // `mesh` for this field to be applicable.
  map<string, string> source_labels = 9;

  // Names of gateways where the rule should be applied. Gateway names
  // in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway
  // match is independent of sourceLabels.
  repeated string gateways = 10;

  // Query parameters for matching.
  //
  // Ex:
  //
  // - For a query parameter like "?key=true", the map key would be "key" and
  //   the string match could be defined as `exact: "true"`.
  //
  // - For a query parameter like "?key", the map key would be "key" and the
  //   string match could be defined as `exact: ""`.
  //
  // - For a query parameter like "?key=abc" or "?key=abx", the map key would be "key" and the
  //   string match could be defined as `prefix: "ab"`.
  //
  // - For a query parameter like "?key=123", the map key would be "key" and the
  //   string match could be defined as `regex: "\d+$"`. Note that this
  //   configuration will only match values like "123" but not "a123" or "123a".
  map<string, StringMatch> query_params = 11;

  // Flag to specify whether the URI matching should be case-insensitive.
  //
  // **Note:** The case will be ignored only in the case of `exact` and `prefix`
  // URI matches.
  bool ignore_uri_case = 12;

  // withoutHeader has the same syntax with the header, but has opposite meaning.
  // If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
  map<string, StringMatch> without_headers = 13;

  // Source namespace constraining the applicability of a rule to workloads in that namespace.
  // If the VirtualService has a list of gateways specified in the top-level `gateways` field,
  // it must include the reserved gateway `mesh` for this field to be applicable.
  string source_namespace = 14;

  // The human readable prefix to use when emitting statistics for this route.
  // The statistics are generated with prefix route.<stat_prefix>.
  // This should be set for highly critical routes that one wishes to get "per-route" statistics on.
  // This prefix is only for proxy-level statistics (envoy_*) and not service-level (istio_*) statistics.
  // Refer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-route-stat-prefix
  // for statistics that are generated when this is configured.
  string stat_prefix = 15;
}

// Describes how to match a given string. Match is case-sensitive.
message StringMatch {
  oneof match_type {

    // exact string match
    string exact = 1;

    // prefix-based match
    string prefix = 2;

    // RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
    string regex = 3;
  }
}

// Describes how to match K8s resources.
//
// ```yaml
//  relatedResources:
//  - apiGroups:
//    - ""
//    namespaces:
//    - '*'
//    resources:
//    - pods
//    verbs:
//    - delete
// ```
message ResourceMatch {

  // `apiGroups` is a list of matching API groups and may not be empty.
  // "*" matches all API groups and, if present, must be the only entry.
  // +listType=set
  // Required.
  repeated string apiGroups = 1;

  reserved 2;
  reserved "names";

  // `namespaces` is a list of target namespaces that restricts
  // matches.  A request that specifies a target namespace matches
  // only if either (a) this list contains that target namespace or
  // (b) this list contains "*".  Note that "*" matches any
  // specified namespace but does not match a request that _does
  // not specify_ a namespace (see the `clusterScope` field for
  // that).
  // This list may be empty, but only if `clusterScope` is true.
  // +optional
  // +listType=set
  repeated string namespaces = 3;
  repeated string resources = 4;

  // `verbs` is a list of matching verbs and may not be empty.
  // "*" matches all verbs and, if present, must be the only entry.
  // +listType=set
  // Required.
  repeated string verbs = 5;
}

message ResourcePolicyRule {
  // `verbs` is a list of matching verbs and may not be empty.
  // "*" matches all verbs and, if present, must be the only entry.
  // +listType=set
  // Required.
  repeated string verbs = 1;

  // `apiGroups` is a list of matching API groups and may not be empty.
  // "*" matches all API groups and, if present, must be the only entry.
  // +listType=set
  // Required.
  repeated string apiGroups = 2;

  // `resources` is a list of matching resources (i.e., lowercase
  // and plural) with, if desired, subresource.  For example, [
  // "services", "nodes/status" ].  This list may not be empty.
  // "*" matches all resources and, if present, must be the only entry.
  // +listType=set
  // Required.
  repeated string resources = 3;

  // `clusterScope` indicates whether to match requests that do not
  // specify a namespace (which happens either because the resource
  // is not namespaced or the request targets all namespaces).
  // If this field is omitted or false then the `namespaces` field
  // must contain a non-empty list.
  // +optional
  optional bool clusterScope = 4;

  // `namespaces` is a list of target namespaces that restricts
  // matches.  A request that specifies a target namespace matches
  // only if either (a) this list contains that target namespace or
  // (b) this list contains "*".  Note that "*" matches any
  // specified namespace but does not match a request that _does
  // not specify_ a namespace (see the `clusterScope` field for
  // that).
  // This list may be empty, but only if `clusterScope` is true.
  // +optional
  // +listType=set
  repeated string namespaces = 5;
}

